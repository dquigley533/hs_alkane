# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_alkane', [dirname(__file__)])
        except ImportError:
            import _alkane
            return _alkane
        if fp is not None:
            try:
                _mod = imp.load_module('_alkane', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _alkane = swig_import_helper()
    del swig_import_helper
else:
    import _alkane
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def timer_init():
  """
    timer_init()

    Initialises the internal calculation timer to zero. This should
    be invoked at the start of any calculation using this module.

    The timer is used to report on performance (MC steps / second)
    and to shutdown cleanly within the walltime of a batch processed
    calculation.

    See also timer_elapsed_time() and timer_check_runtime(). 

    Parameters
    ----------

    (none)


    """
  return _alkane.timer_init()

def timer_check_continuation():
  """
    timer_check_continuation()

    Returns an integer flag (1/0) indicating if calculation
    is safe to continue without running out of walltime.

    See also timer_init() and timer_elapsed_time(). 

    Returns
    ----------

    1 if remaining walltime > timer_closetime
    0 otherwise (calculation should halt)


    """
  return _alkane.timer_check_continuation()

def timer_elapsed_time():
  """
    timer_elapsed_time()

    Returns a double precision number indicating the elapsed
    seconds since timer_init() was invoked.

    See also timer_init() and timer_check_runtime(). 

    Parameters
    ----------

    (none)

    Returns
    -------

    Time in seconds.


    """
  return _alkane.timer_elapsed_time()

def random_set_random_seed(*args):
  """
    random_set_random_seed(seed)

    Seeds the random number generator used internally by the 
    hs_alkane library. Use seed=0 to generate seed based on 
    the current system time.

    Parameters
    ----------

    seed       : integer random number seed


    """
  return _alkane.random_set_random_seed(*args)

def random_uniform_random():
  """
    random_uniform_random()

    Uses the random number generator internal to the hs_alkane
    library to return a random number on the interval [0,1).

    Returns
    ----------

    xi       : double precision random number


    """
  return _alkane.random_uniform_random()

def quat_get_minimum_arc(*args):
  """
    quat_get_minimum_arc(unit_vector1, unit_vector2)

    Returns a quaternion which represents rotation of unit_vector1
    onto unit_vector2 via the minimum arc

    Parameters
    ----------

    unit_vector1 : numpy array, unit vector before rotation
    unit_vector2 : numpy array, unit vector after rotation


    Returns
    ----------

    quaternion    : quaternion representing the rotation


    """
  return _alkane.quat_get_minimum_arc(*args)

def quat_axis_angle_to_quat(*args):
  """
    quat_axis_angle_to_quat(rotation_axis, angle)

    Returns a quaternion which represents rotation of a vector 
    around an axis by some angle.

    Parameters
    ----------

    rotation_axis : numpy array, unit vector about which to rotate
    angle         : rotation angle (radians)


    Returns
    ----------

    quaternion    : quaternion representing the rotation


    """
  return _alkane.quat_axis_angle_to_quat(*args)

def quat_product(*args):
  """
    quat_product(quaternion1, quaternion2, normalised)

    Returns a quaternion which represents the rotation equivalent
    to the rotation represented by quaternion1 followed by the
    rotation represented by quaternion2. 

    Parameters
    ----------

    quaternion1 : numpy array, quaternion representing first rotation
    quaternion2 : numpy array, quaternion representing second rotation
    normalised  : integer flag (1/0) indicating if output quaternion
                  should be normalised


    Returns
    ----------

    quaternion    : quaternion representing combined rotation


    """
  return _alkane.quat_product(*args)

def quat_inverse(*args):
  """
    quat_inverse(quaternion)

    Returns a quaternion which represents the inverse rotation
    of a quaternion the rotation which reverses that input.

    Parameters
    ----------

    quaternion : numpy array, quaternion representing a rotation

    Returns
    ----------

    inverse    : numpy array, quaternion representing inverse rotation


    """
  return _alkane.quat_inverse(*args)

def quat_conjugate_q_with_v(*args):
  """
    quat_conjugate_q_with_v(quaternion,vector)

    Conjugates a quaternion with a vector, i.e. returns a
    vector resulting from applying the rotation represented
    by the quaternion to the vector.

    Parameters
    ----------

    quaternion : numpy array, quaternion representing a rotation
    vector     : numpy array, vector to be rotated

    Returns
    ----------

    out_vector : numpy array, result of the conjugation


    """
  return _alkane.quat_conjugate_q_with_v(*args)

def box_set_num_boxes(*args):
  """
    box_set_num_boxes(num_replicas)

    Sets the number of simulation boxes/replicas to be created
    and simulated. The default number of boxes is 1 and in most
    cases this should not need to be changed. 

    Multiple boxes may be required if implementing advanced
    sampling schemes involving multiple replicas. If so the
    number of boxes must be set before the simulation box and
    associated data structures are initialised. It cannot be
    changed during the simulation without generating
    udefined behaviour.

    Parameters
    ----------

    num_boxes  : number of boxes/replicas to use


    """
  return _alkane.box_set_num_boxes(*args)

def box_get_num_boxes():
  """
    box_get_num_boxes()

    Queries that the number of simulation boxes/replicas that
    are in use currently. This should not change during a simulation.

    Returns
    ----------

    num_boxes  : integer, number of boxes in use


    """
  return _alkane.box_get_num_boxes()

def box_initialise():
  """
    box_initialise()

    Allocates memory for the simulation box(es).

    If an initial set of cell vectors have been specified via a
    call to io_read_input() then these will be used to populate
    these data structures. Alternatively, io_real_xmol() or
    box_set_cell() can be called after box_initialise() can to
    specify the initial cell vectors for simulation.

    Note that cell vectors are not required if periodic boundary
    conditions are not in use - see box_set_pbc. The default is 
    that periodic boundary conditions *will* be used.


    """
  return _alkane.box_initialise()

def box_destroy():
  """
    box_destroy()

    Releases memory used for the simulation box(es).

    This should only be required if needing to reinitialise
    the simulation box(es) for a new simulation.


    """
  return _alkane.box_destroy()

def box_set_cell(*args):
  """
    box_get_cell(ibox)

    Sets the cell matrix containing the three vectors
    which define the 3D simulation cell of box/replica ibox.

    The hs_alkane library adopts the convention that the first
    cell vector always lies along the x-axis, and the second cell 
    vector lies in the x-y plane. 

    Parameters
    ----------

    ibox         : Index (1-based) of the box/replica to set
                   cell vectors for.

    cell_matrix  : Numpy array compatible with that returned
                   by the get_cell() method of an ASE atoms 
                   object.


    """
  return _alkane.box_set_cell(*args)

def box_get_cell(*args):
  """
    Gets the cell matrix containing the three vectors
    which define the 3D simulation cell of box/replica ibox.

    The hs_alkane library adopts the convention that the first
    cell vector always lies along the x-axis, and the second cell 
    vector lies in the x-y plane. 

    Parameters
    ----------

    ibox         : Index (1-based) of the box/replica to get
                   cell vectors from.
                   
    Returns
    -------

    cell_matrix  : Numpy array compatible with that returned
                   by the get_cell() method of an ASE atoms 
                   object.    


    """
  return _alkane.box_get_cell(*args)

def box_cart_to_frac(*args):
  """
    box_cart_to_frac(ibox, vector)

    Converts a vector in Cartesian coordinates to one expressed
    in terms of fractional coordinates of box/replica ibox. 

    Parameters
    ----------

    ibox         : Index (1-based) of the box/replica to use
                   for conversion into fractional coordinates.
                   
    vector       : Numpy array, input Cartesian vector.
                   
    Returns
    -------

    out_vector   : Numpy array, output fractional vector. 



    """
  return _alkane.box_cart_to_frac(*args)

def box_frac_to_cart(*args):
  """
    box_frac_to_cart(ibox, vector)

    Converts a vector in expressed as fraction coordinates of
    box/replica ibox into the same vector in Cartesian coordinates.

    Parameters
    ----------

    ibox         : Index (1-based) of the box/replica in which
                   input fractional coordinates are expressed.
                   
    vector       : Numpy array, input fraction vector.
                   
    Returns
    -------

    out_vector   : Numpy array, output Cartesian vector. 



    """
  return _alkane.box_frac_to_cart(*args)

def box_minimum_image(*args):
  """
    box_minimum_image(ibox, vector1, vector2)

    Finds the shortest periodic image of vector2 - vector1, i.e.
    for two position vectors finds the shortest vector which connects
    the first to the second accross a periodic boundary.

    Parameters
    ----------

    ibox         : Index (1-based) of the box/replica which defines
                   the periodic boundaries of interest.
                   
    vector1      : Numpy array, first position vector.

    vector2      : Numpy array, second position vector.
                   
    Returns
    -------

    out_vector   : Numpy array, output minimum image vector. 



    """
  return _alkane.box_minimum_image(*args)

def box_set_link_cell_length(*args):
  """
    box_set_link_cell_length(length)

    Sets the minimum size of a link cell in any direction in any
    simulation box. Smaller values increase the number of link
    cells and hence reduce the computational cost of finding
    distances between beads. 

    Link cells must be sufficiently large that all relevant
    interactions between bead i and bead j are captured within
    the 27 link cells enclosing and adjacent to that containing
    bead i. For hard sphere this means that the minimum link
    cell size in any direction must be at least a hard sphere
    diameter.

    The default mimimum length is 1.5 units which is appropriate
    for a bead radius of 1 provided the simulation cell angles
    remain within sensible limits, i.e. 60 to 120 degrees. 

    Smaller values may improve performance for simulation cells
    which are guaranteed to remain near cuboidal.

    Note that the subsequent use of link cells assume that any
    distortion/shinkage/expansion of the simulation box(es)
    will not invalidate this parameter.

    Parameters
    ----------

    length       : Minimum length of link cells in any direction.


    """
  return _alkane.box_set_link_cell_length(*args)

def box_construct_link_cells(*args):
  """
    box_construct_link_cells(ibox)

    Constructs and populates the link cell data structure for
    box/replica ibox. Should be called after populating 
    the initial cell_matrix of box/replica ibox.

    Subsequent use of link cells assumes that any
    distortion/shinkage/expansion of the simulation box(es)
    will not invalidate the ability of the link cell
    data structure to capture all relevant interactions
    between pairs of beads.   

    Parameters
    ----------

    ibox         : Index (1-based) of the box/replica.


    """
  return _alkane.box_construct_link_cells(*args)

def box_destroy_link_cells():
  """
    box_destroy_link_cells

    Releases memory used for the link cell data structure.

    This should only be required if needing to reinitialise
    the link cell structure for a new simulation. 


    """
  return _alkane.box_destroy_link_cells()

def box_set_bypass_link_cells(*args):
  """
    box_set_bypass_link_cells(flag)

    Sets a flag which instructs the hs_alkane library to bypass
    use of link cells and calculate all pairwise interactions
    directly using the minimum image convention.

    This can be useful if expecting the simulation cell/size
    to change significantly during simulation, or is the system
    is too small to make efficient use of link cells.

    The default is that links cells *will* be used.

    Parameters
    ----------

    flag         : Integer (1 or 0) indicating if link cells
                   should be bypassed.


    """
  return _alkane.box_set_bypass_link_cells(*args)

def box_update_recipmatrix(*args):
  return _alkane.box_update_recipmatrix(*args)
box_update_recipmatrix = _alkane.box_update_recipmatrix

def box_compute_volume(*args):
  """
    box_compute_volume(ibox))

    Calculates the volume of the simulation cell for the specified
    simulation box/replica.

    Parameters
    ----------

    ibox         : Index (1-based) of the box/replica.

    Returns
    -------

    volume       : Volume of simulation box/replica ibox. 
                   

    """
  return _alkane.box_compute_volume(*args)

def box_set_isotropic(*args):
  return _alkane.box_set_isotropic(*args)
box_set_isotropic = _alkane.box_set_isotropic

def box_set_use_verlet_list(*args):
  """
    box_set_use_verlet_list(flag)

    If link cells are not in use then this flag can be used to
    force use of Verlet neighbour lists when computing distances
    between position vectors in the simulation box(es).

    * CURRENTLY NON FUNCTIONAL *

    Parameters
    ----------

    flag         : Integer (1 or 0) indicating if Verlet lists
                   should be used in the case where link cells
                   are bypassed.


    """
  return _alkane.box_set_use_verlet_list(*args)

def box_set_pbc(*args):
  """
    box_set_pbc(flag)

    Can be used to set an internal variable which overrides use
    of periodic boundary conditions when calculating distances
    between position vectors in the simulation. 

    Should be called with flag=0 at the start of a simulation
    after box_initialise() if an open system simulation is required.
    Otherwise periodic boundary conditions will be used by default.

    Parameters
    ----------

    flag         : Integer (1 or 0) indicating if periodic
                   boundaries should be applied to the calculation
                   of distances between position vectors.  
                   

    """
  return _alkane.box_set_pbc(*args)

def alkane_get_nchains():
  """
    alkane_get_nchains();

    Returns the number of chains currently in use within the simulation.


    Returns
    -------

    nchains      : Integer number of chains. 


    """
  return _alkane.alkane_get_nchains()

def alkane_set_nchains(*args):
  """
    alkane_set_nchains(nchains);

    Sets the number of chains to use within the simulation. Subsequent
    calls to alkane_init will allocate data structures to hold this 
    number of chains. 

    Can be modified during the simulation. This is useful for when the
    number of chains is changing, such as when growing new random 
    chain configurations to avoid checking for overlaps with chains
    that have not yet been created.

    Parameters
    ----------

    nchains      : Integer number of chains to use during the simulation. 



    """
  return _alkane.alkane_set_nchains(*args)

def alkane_get_nbeads():
  """
    alkane_get_nbeads(int_*nbeads);

    Returns the number of beads per chain currently in use within the 
    simulation.

    Returns
    -------

    nbeads      : Integer number of beads per chain 


    """
  return _alkane.alkane_get_nbeads()

def alkane_set_nbeads(*args):
  """
    alkane_set_nbeads(nbeads);

    Sets the number of beans per chain to use within the simulation. 
    Subsequent calls to alkane_init will allocate data structures to hold
    this many beads per chain. 

    Parameters
    ----------

    nbeads      : Bumber of beads per chain to use during the simulation. 


    """
  return _alkane.alkane_set_nbeads(*args)

def alkane_initialise():
  """
    alkane_initialise();

    Creates data structures to hold information on the current configuration
    of beads/chains in all simualtion boxes/replicas. Must be called before
    calling routines which implement trial Monte Carlo moves on the configuration.

    Requires that the simulation box has been initialised via box_initialise().

    This routine can be invoked multiple times within a session. Each call
    will result in destruction of the existing data structures and their
    contents before creating new ones. This can be used to implement
    multiple simulations within one Python session.



    """
  return _alkane.alkane_initialise()

def alkane_construct_linked_lists(*args):
  """
    alkane_construct_linked_lists(int_ibox);

    Creates and populates the linked list data structures used to 
    accelerate computation of neighbour distances in box ibox.

    Can be invoked manually to ensure current linked lists are 
    valid, but is normally called only by other routine which
    change the size/shape of the simulation cell.

    See alkane_update_linked_lists for single bead updates of the 
    linked list data structures. 

    Link cell data structures in the box module must be up-to-date
    when calling this rouine. See box_construct_link_cells().

    Has no effect if use of link cells has been bypassed see
    box_set_bypass_link_cells().

    Parameters
    ----------

    ibox        : Box/replica for which to construct linked lists


    """
  return _alkane.alkane_construct_linked_lists(*args)

def alkane_destroy():
  """
    alkane_destroy();

    Destroys all data structures related to beads/chains in the
    simulation cell. Acts on all boxes/replicas.

    Use alkane_initialise() to both delete these data structures
    and create new ones.


    """
  return _alkane.alkane_destroy()

def alkane_grow_chain(*args):
  """
    alkane_grow_chain(ichain,ibox,new_conf);

    Grows a new chain configuration for chain ichain in box 
    ibox from a randomly selected bead onwards. Uses Rosenbluth
    sampling. Primarily used for configurational bias Monte Carlo.

    Invoke with new_conf=0 to compute the Rosenbluth factor for 
    the existing chain configuration, and new_conf=0 to compute
    the Rosenbluth factor for a new trial configuration

    If the chain has not previously been assigned coordinates then
    a new chain is grown from the first bead if new_conf=1. This 
    can be useful in creating random initial configurations. 

    If ifail is non-zero then the algorithm has failed to generate
    a trial chain segment which has no overlaps with other beads. 
    The number of trial attempts (ktrial) can be changed via
    alkane_set_ktrial().

    The maximum number of beads which are (re)grown by the trial
    move is controlled via alkane_set_max_regrow().


    Parameters
    ----------

    ichain     :  Integer (1-based) chain to grow/regrow
    ibox       :  Integer (1-based) box/replica to use
    new_conf   :  1 to grow new chain, 0 otherwise

    Returns
    -------

    rb_factor  : Rosenbluth factor for existing/trial chain
    ifail      : non-zero integer if chain growth failed



    """
  return _alkane.alkane_grow_chain(*args)

def alkane_get_chain(*args):
  """
    alkane_get_chain(ichain,ibox);

    Returns a Numpy array containing the bead coordinates of chain 
    ichain in box/replica ibox.

    NOTE : Note the returned Numpy array is a 'view' of the internal
    representation of coordinates. Updating the elements of the Numpy
    array will update the coordinates inside the model. This avoids
    making copies. i.e. 

    mychain = mdl.alkane_get_chain(ichain, ibox)
    mychain[0][2] = 3.4

    will modify the z coordinate of bead zero in the chain within
    the model.

    Note also however that assigning the name of the Numpy array  
    to a new array will *not* update the model, so

    mychain = mdl.alkane_get_chain(ichain, ibox)
    mychain = np.zeros(3,Nbeads)

    will not set all coordinate for the chain to zero. Instead
    it will replace the Numpy array holding the 'view' of the 
    chain coordinates with another empty array not linked to 
    the internal model data.

    Parameters
    ----------

    ichain     :  Integer (1-based) chain index
    ibox       :  Integer (1-based) box/replica index

    Returns
    -------

    chain_out  :  Numpy array with 'view' of model chain coordinates


    """
  return _alkane.alkane_get_chain(*args)

def alkane_translate_chain(*args):
  """
    alkane_translate_chain(ichain,ibox);

    Makes a trial translation move by translating an entire chain in
    a random direction by a distance between zero and dr_max.

    Returns the probability of accepting the move, which will be 1
    if the move generates no overlaps with other beads, zero otherwise.

    See also alkane_set_dr_max() and alkane_get_dr_max().

    Parameters
    ----------

    ichain     :  Integer (1-based) chain index to translate
    ibox       :  Integer (1-based) box/replica index to use


    Returns
    -------

    boltz      :  Probability of accepting the trial move


    """
  return _alkane.alkane_translate_chain(*args)

def alkane_rotate_chain(*args):
  """
    alkane_rotate_chain(ichain,ibox,bond);

    Makes a trial rotation move by rotating an entire chain about
    a random axis by an angle between zero and dt_mx.

    If the input parameter bond is equal to 1 then the chain will
    be rotated around an axis defined by the vector connecting
    bead 0 to bead 1 on that chain. For dense packed systems of linear 
    chains replacing some (large) fraction of standard rotation 
    moves with moves of this type can improve sampling efficiency. 
    In this case the random rotation is between zero and axis_max.

    Returns the probability of accepting the move, which will be 1
    if the move generates no overlaps with other beads, zero otherwise.
    The quaternion representing the trial rotation is also returned.

    See also alkane_set_dr_max() and alkane_get_dr_max() or
             alkane_set_axis_max() and alkane_get_axis_max()

    Parameters
    ----------

    ichain     :  Integer (1-based) chain index to rotate
    ibox       :  Integer (1-based) box/replica index to use
    bond       :  Integer (1 or 0) rotate around first bond

    Returns
    -------

    boltz      :  Probability of accepting the trial move
    quat       :  Quaternion representing the rotation 


    """
  return _alkane.alkane_rotate_chain(*args)

def alkane_bond_rotate(*args):
  """
    alkane_bond_rotate(ichain,ibox,allow_flip);

    Makes a trial move in which a randomly selected dihedral angle
    on chain ichain in box/replica ibox is rotated by an angle
    between zero and dh_max. Additionally, if allow_flip=1
    there is a probabilty of 50% that an additional 
    2Pi/3 radians is added such that the chains flips between
    'gauche' and 'anti' conformations about this bond.

    See also alkane_set_dh_max() and alkane_get_dh_max()

    Parameters
    ----------

    ichain     :  Integer (1-based) chain index to use
    ibox       :  Integer (1-based) box/replica index to use
    allow_flip :  Integer (1 or 0) include flips between conformations

    Returns
    -------

    ia         : First bead involved in the dihedral angle
    angle      : Angle of rotation about the bond
    boltz      : Probability of accepting the trial move


    """
  return _alkane.alkane_bond_rotate(*args)

def alkane_check_chain_overlap(*args):
  """
    alkane_check_chain_overlap(ibox);

    Checks if simulation box/replica ibox contains any overlaps
    between beads. Both inter and intra-chain overlaps are
    detected. As specified by the choice of model, interactions
    between beads on the same chain seperated by 1, 2 and (in 
    some cases) 3 bonds are ignored.

    Useful as a sanity check. There should never be any overlaps
    if all list structures are up-to-date and no moves which 
    generate overlaps have been accepted.

    Parameters
    ----------

    ibox       :  Integer (1-based) box/replica index to use

    Returns
    -------

    overlap    :  Integer (1/0) indicating if overlaps are present


    """
  return _alkane.alkane_check_chain_overlap(*args)

def alkane_check_chain_geometry(*args):
  """
    alkane_check_chain_geometry(int_ichain,_int_ibox,_int_*violated);

    Checks that the internal geometry of chain ichain in box/replica
    ibox is consistent with the model bond length and bond angle  
    constraints.

    Parameters
    ----------

    ichain     :  Integer, chain to check (1-based)
    ibox       :  Integer (1-based) box/replica index to use

    Returns
    -------

    violated   :  Integer (1/0) indicatign if contraints are violated


    """
  return _alkane.alkane_check_chain_geometry(*args)

def alkane_update_linked_lists(*args):
  """
    alkane_update_linked_lists(ibead,ichain,ibox,old_pos[3],new_pos[3]);

    Updates the linked list data structure to account for bead ibead
    on chain ichain in box ibox having moved from position old_pos
    to new_pos. 

    In principle this should be used after every accepted trial move
    which changes a bead position. However for mostly static solids, 
    the set of link cells which contains all neighbours of each bead
    is unlikely to change and link list updates can (with caution) be
    omitted.


    Parameters
    ----------

    ibead      :  Index (1-based) of bead on ichain to update
    ichain     :  Integer, chain on which bead resides (1-based)
    ibox       :  Integer (1-based) box/replica index to use
    old_pos    :  Numpy array - old x,y,z coords of bead
    new_pos    :  Numpy array - new x,y,z coords of bead


    """
  return _alkane.alkane_update_linked_lists(*args)

def alkane_construct_neighbour_list(*args):
  """
    alkane_construct_neighbour_list(ibox);

    Creates a Verlet neighbour for all beads in simulation box/replica ibox.
    A neighbour list can be used instead of link cells to accelerate
    checks for overlaps between builds. See

    box_set_bypass_link_cells()
    box_set_use_verlet_list()

    All neighbours of a bead within a distance of two bead diameters
    are added into the neighbour list.

    There is no automatic update of the neighbour list to account for 
    movement of beads. This function should be called whenever 
    neighbours are likely to have moved sufficiently that the previous
    neighbour list has been invalidatd.


    Parameters
    ----------

    ibox       :  Integer (1-based) box/replica index to construct for


    """
  return _alkane.alkane_construct_neighbour_list(*args)

def alkane_get_dr_max():
  """
    alkane_get_dr_max();

    Queries the maximum distance a chain will be moved during a 
    trial Monte Carlo translation.

    Returns
    -------

    dr_max     :  Maximum displacement


    """
  return _alkane.alkane_get_dr_max()

def alkane_set_dr_max(*args):
  """
    alkane_set_dr_max(dr_max);

    Sets the maximum distance a chain will be moved during a 
    trial Monte Carlo translation.

    Parameters
    ----------

    dr_max     :  Maximum displacement


    """
  return _alkane.alkane_set_dr_max(*args)

def alkane_get_dt_max():
  """
    alkane_get_dt_max();

    Queries the maximum distance a chain will be moved during a 
    trial Monte Carlo translation.

    Returns
    -------

    dr_max     :  Maximum displacement


    """
  return _alkane.alkane_get_dt_max()

def alkane_set_dt_max(*args):
  """
    alkane_set_dt_max(dt_max);

    Sets the maximum angle a chain will be rotated around
    a random axis during a Monte Carlo trial rotation.

    Parameters
    ----------

    dt_max     :  Maximum rotation angle




    """
  return _alkane.alkane_set_dt_max(*args)

def alkane_get_axis_max():
  """
    alkane_get_axis_max();

    Queries the maximum angle a chain will be rotated around
    an axis through its first bond vector during a Monte
    Carlo trial rotation.

    Returns
    -------

    axis_max     :  Maximum rotation angle around bond axis


    """
  return _alkane.alkane_get_axis_max()

def alkane_set_axis_max(*args):
  """
    alkane_set_axis_max(axis_max);

    Sets the maximum angle a chain will be rotated around
    an axis through its first bond vector during a Monte
    Carlo trial rotation.

    Parameters
    ----------

    axis_max     :  Maximum rotation angle around bond axis


    """
  return _alkane.alkane_set_axis_max(*args)

def alkane_get_dh_max():
  """
    alkane_get_dh_max();

    Queries the maximum change in dihedral angle made during
    a trial Monte Carlo rotation about a random bond.

    Returns
    -------

    dh_max       :  Maximum rotation angle around bond 


    """
  return _alkane.alkane_get_dh_max()

def alkane_set_dh_max(*args):
  """
    alkane_set_dh_max(dh_max);

    Sets the maximum change in dihedral angle made during
    a trial Monte Carlo rotation about a random bond.

    Returns
    -------

    dh_max       :  Maximum rotation angle around bond 


    """
  return _alkane.alkane_set_dh_max(*args)

def alkane_get_dv_max():
  """
    alkane_get_dv_max();

    Queries the parameter used to determine the maximum 
    change in the simulation cell during a trial move as
    implemented in alkane_box_resize().

    For anisotopic box moves this parameter controls the
    maximum change in any component of a randomly selected
    cell vector. For isotropic (pure expansion/contraction)
    volume moves the parameter controls the maximum 
    change in volume.

    See also box_get_isotropic().

    Returns
    -------

    dv_max       :  Maximum box change parameter

    """
  return _alkane.alkane_get_dv_max()

def alkane_set_dv_max(*args):
  """
    alkane_set_dv_max(dv_max);

    Sets the parameter used to determine the maximum 
    change in the simulation cell during a trial move as
    implemented in alkane_box_resize().

    For anisotopic box moves this parameter controls the
    maximum change in any component of a randomly selected
    cell vector. For isotropic (pure expansion/contraction)
    volume moves the parameter controls the maximum 
    change in volume.

    See also box_set_isotropic().

    Parameters
    ----------

    dv_max       :  Maximum box change parameter


    """
  return _alkane.alkane_set_dv_max(*args)

def alkane_get_ktrial():
  """
    alkane_get_ktrial();

    Queries the parameter which controls the number of trial
    chain segments used at each bead when (re)growing chains
    in alkane_grow_chain(). 

    Returns
    -------

    ktrial      :   Number of trials  


    """
  return _alkane.alkane_get_ktrial()

def alkane_set_ktrial(*args):
  """
    alkane_set_ktrial(int_ktrial);

    Sets the parameter which controls the number of trial
    chain segments used at each bead when (re)growing chains
    in alkane_grow_chain(). 

    Parameters
    ----------

    ktrial      :   Number of trials  


    """
  return _alkane.alkane_set_ktrial(*args)

def alkane_get_max_regrow():
  """
    alkane_get_max_regrow();

    Queries the maximum number of beads/segments to (re)grow 
    during a configurational bias Monte Carlo move as 
    implemented in alkane_grow_chain().

    Returns
    -------

    max_regrow  : Maximum number of beads/segments to regrow


    """
  return _alkane.alkane_get_max_regrow()

def alkane_set_max_regrow(*args):
  """
    alkane_set_max_regrow(int_dum_max_regrow);

    Sets the maximum number of beads/segments to (re)grow 
    during a configurational bias Monte Carlo move as 
    implemented in alkane_grow_chain().

    Parameters
    ----------

    max_regrow  : Maximum number of beads/segments to regrow


    """
  return _alkane.alkane_set_max_regrow(*args)

def alkane_change_box(*args):
  """
    alkane_change_box(ibox,delta_H[3][3]);

    Changes the matrix of simulation cell vectors in box ibox
    by a matrix delta_H (3x3 Numpy array). Fractional positions
    of the first bead in each chain are preserved.

    This may lead to chain overlaps which are not tested. Note that
    this function does not implement a trial move to be accepted
    or rejected. It is provided for the purposes of implementing
    higher-level sampling algorithms in the calling routine.

    Parameters
    ----------

    ibox        : Simulation box/replica to change
    delta_H     : 3x3 Numpy array - change in matrix of cell vectors


    """
  return _alkane.alkane_change_box(*args)

def alkane_box_scale(*args):
  """
    alkane_box_scale(int_ibox,_double_scaleA,_double_scaleB,_double_scaleC);

    Changes the matrix of simulation cell vectors in box ibox
    by scaling the three cell vectors by the factors specified.
    Fractional positions of the first bead in each chain are preserved.

    This may lead to chain overlaps which are not tested. Note that
    this function does not implement a trial move to be accepted
    or rejected. It is provided for the purposes of implementing
    higher-level sampling algorithms in the calling routine.

    Parameters
    ----------

    ibox        : Simulation box/replica to change
    scaleA      : Scaling factor for first  cell vector
    scaleB      : Scaling factor for second cell vector
    scaleC      : Scaling factor for third  cell vector 


    """
  return _alkane.alkane_box_scale(*args)

def alkane_box_resize(*args):
  """
    alkane_box_resize(pressure,ibox,reset);

    Implements a trial Monte Carlo move in which the size/shape
    of simulation box is changed by a random amount controled
    by the parameter dv_max.

    For isotropic moves a random change involume between 
    -dv_max and +dv_max is proposed. For anisotropic moves a
    randomly selected component of cell vector is changed by
    an amount between -dv_max and +dv_max.

    Fractional positions of the first bead in each chain are
    preserved in each case.

    See also alkane_set_dv_max(), box_set_isotropic().

    If the parameter reset=1 then the most recently proposed
    move of this kind is reversed, implementing rejection.


    Parameters
    ----------

    Pressure     : Simulation pressure in reduced units
    ibox         : Simulation box/replica to modify
    reset        : Integer (0/1) reverse previous box resize move

    Returns
    -------

    boltz        : Probability of accepting move


    """
  return _alkane.alkane_box_resize(*args)

def write_psf(*args):
  """
    write_psf(nbeads,nchains);

    Write a Protein Structure (topology) files to chain.psf. This file
    contains bonding information and can be used in the VMD molecular
    simulation software to definate a structure into which coordinates
    are then read from dcd file(s). 

    If the simulation consists of multiple boxes/replicas then one file
    is created for each, i.e. chain.psf.01 chain.psf.02 etc.

    See also write_dcd_header(), write_dcd_snapshot().

    Parameter
    ---------

    nbeads    : Number of beads per chain in the simulation(s)
    nchains   : Number of chains in the simulation(s)


    """
  return _alkane.write_psf(*args)

def write_dcd_header(*args):
  """
    write_dcd_header(nbeads,nchains);

    Writes the header of a Charmm-style dcd file to which snapshots
    of bead coordinates can subsequently be dumped via write_dcd_snapshot.
    The header is written to chain.dcd, which is overwritten if it 
    already exists.

    If the simulation consists of multiple boxes/replicas then one file
    is created for each, i.e. chain.dcd.01 chain.dcd.02 etc.

    See also write_psf(), write_dcd_snapshot().

    Parameter
    ---------

    nbeads    : Number of beads per chain in the simulation(s)
    nchains   : Number of chains in the simulation(s)


    """
  return _alkane.write_dcd_header(*args)

def write_dcd_snapshot():
  """
    write_dcd_snapshot();

    Appends a snapshot of the current model configuration to the chain.dcd
    file previously created by a call to write_dcd_header().

    If the simulation consists of multiple boxes/replicas then one file
    is used for each, i.e. chain.dcd.01 chain.dcd.02 etc.

    The dcd file(s) can be read by the VMD visualisation software 
    by loading them into a configuration previous read from chain.psf.

    See also write_psf(), write_dcd_header().

    """
  return _alkane.write_dcd_snapshot()

def io_read_xmol(filename="chain.xmol"):
  """
    io_read_xmol(filename);

    Reads an initial configuration for the simulation(s) from
    filename in the current working directory. This should be 
    structured as a standard xyz file, with the 9 components
    of the matrix of cell vectors listed on the second line.

    The nbeads beads on the first chain should appear sequentially
    as entries 1-nbeads, followed by the second chain, and so on.

    The data structures inside the alkane module must have been
    created via alkane_initialise() before calling this function.

    If the simulation consists of multiple boxes/replicas then one file
    is read for each, i.e. chain.xmol.0001 chain.xmol.0002 etc.

    Parameter
    ---------

    filename   : Filename to read (optional). Uses chain.xmol otherwise.




    """
  return _alkane.io_read_xmol(filename)
# This file is compatible with both classic and new-style classes.

cvar = _alkane.cvar

